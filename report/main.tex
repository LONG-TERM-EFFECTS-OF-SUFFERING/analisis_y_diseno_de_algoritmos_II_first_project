\input{configuration.tex}
\input{front_page.tex}

\begin{document}

\maketitle

\pagenumbering{gobble}

\tableofcontents

\clearpage

\pagenumbering{arabic}

\section{Programación voraz}

Durante el desarrollo de soluciones heurísticas para el problema de moderación de opiniones en redes sociales (ModCI), se planteó como objetivo diseñar una estrategia \textbf{voraz} que, si bien no garantizara la solución óptima, pudiera ofrecer resultados cercanos al óptimo en tiempos razonables. Este enfoque es especialmente valioso para redes de gran tamaño, donde las soluciones exactas resultan computacionalmente costosas.

\subsection{Variantes de estrategias voraces evaluadas}

El proceso comenzó con la definición de \textbf{métricas de priorización} para determinar el orden en que deberían moderarse los grupos de agentes. Cada variante compartía una estructura general similar:

\begin{enumerate}
	\item \textbf{Ordenar los grupos} según una métrica específica.

	\item \textbf{Recorrer secuencialmente los grupos ordenados}, moderando agentes en cada uno hasta agotar el presupuesto de esfuerzo disponible.
\end{enumerate}

Las métricas evaluadas para ordenar los grupos incluyeron:

\begin{itemize}
	\item \textbf{Discrepancia absoluta}: prioriza grupos con mayor desacuerdo interno entre opiniones.
	$|o_1 - o_2|$

	\item \textbf{Radio discrepancia/rigidez}: favorece grupos donde la discrepancia es alta y la rigidez es baja, buscando así un mayor impacto en la reducción del conflicto interno a un menor costo.
	$\frac{ |o_1 - o_2| }{ r }$

	\item \textbf{Reducción conflicto por esfuerzo necesario}: se toma el aporte que hace cada grupo a la reducción del conflicto interno (numerador) y se divide por el esfuerzo necesario para moderar un solo agente de ese grupo (denominador), dando una idea de la eficiencia en la reducción del conflicto interno por grupo, teniendo en cuenta su costo.
	$\frac{ (o_1 - o_2)^2 }{ |o_1 - o_2| r }$
\end{itemize}

Cada una de estas métricas fue implementada en su correspondiente estrategia voraz, siguiendo la estructura común, y se llevaron a cabo pruebas sistemáticas para evaluar su desempeño sobre distintos casos de prueba. Estas pruebas compararon inicialmente el \textbf{conflicto interno resultante} y su cercanía a la solución óptima. Esto dio como resultado la siguiente tabla:

\begin{table}[H]
	\centering
	\small
	\begin{tabular}{|c|c|c|c|c|c|}
		\hline
		\textbf{Prueba} & \textbf{Discrepancy-rigidity} & \textbf{Efficiency} & \textbf{Discrepancy-rigidity-one-at-a-time} & \textbf{Discrepancy} & \textbf{Óptimo} \\ \hline
		1 & 0 & 0 & 0 & 0 & 0,0 \\ \hline
		2 & 19616,4 & 32090 & 19667,6 & 21428,4 & 19616,4 \\ \hline
		3 & 1621,6 & 5776 & 1727,4 & 2423,6 & 1621,6 \\ \hline
		4 & 5103,8 & 13491 & 5219 & 5924,6 & 5103,8 \\ \hline
		5 & 14369 & 20981,6 & 14369 & 16287 & 14369,0 \\ \hline
		6 & 31002,7 & 36483,3 & 32086,1 & 40174,1 & 31002,7 \\ \hline
		7 & 2762,9 & 8941,4 & 3012,9 & 2827,7 & 2762,9 \\ \hline
		8 & 22057 & 31613,9 & 22178 & 23647,2 & 21948,9 \\ \hline
		9 & 75544,6 & 77092 & 75954,2 & 81186,2 & 75544,6 \\ \hline
		10 & 0 & 0 & 0 & 0 & 0,0 \\ \hline
		11 & 19615,9 & 29174,8 & 20911,733 & 28848,133 & 19391,9 \\ \hline
		12 & 16558,3 & 18361,2 & 16696,933 & 20843,6 & 16558,3 \\ \hline
		13 & 43861 & 69317,2 & 44072,6 & 44072,6 & 43861,0 \\ \hline
		14 & 22732,3 & 37460,333 & 23286,466 & 40054,6 & 22694,3 \\ \hline
		15 & 68944,4 & 97733,6 & 69209 & 70267,4 & 68944,4 \\ \hline
		16 & 0 & 0 & 0 & 0 & 0,0 \\ \hline
		17 & 771,15 & 8527,8 & 919,4 & 2552,55 & 771,2 \\ \hline
		18 & 28062,6 & 34011,56 & 28423,96 & 33411,84 & 28058,1 \\ \hline
		19 & 0 & 0 & 0 & 0 & 0,0 \\ \hline
		20 & 12572,6 & 22393,28 & 13295,48 & 14685 & 12431,4 \\ \hline
		21 & 0 & 0 & 0 & 0 & 0,0 \\ \hline
		22 & 0 & 0 & 0 & 0 & 0,0 \\ \hline
		23 & 0 & 0 & 0 & 0 & 0,0 \\ \hline
		24 & 0 & 0 & 0 & 0 & 0,0 \\ \hline
		25 & 0 & 0 & 0 & 0 & 0,0 \\ \hline
		26 & 28988,2 & 35850,88 & 29283,48 & 33048,16 & 28988,2 \\ \hline
		27 & 25110,6 & 39758,06 & 25392,42 & 29556,6 & 25102,4 \\ \hline
		28 & 937,23 & 3129,11 & 991,18 & 1248,81 & 930,0 \\ \hline
		29 & 0 & 0 & 0 & 0 & 0,0 \\ \hline
		30 & 0 & 0 & 0 & 0 & 0,0 \\ \hline
	\end{tabular}
\end{table}

\subsection{Selección de la mejor estrategia}

En los resultados de la tabla anterior, se puede apreciar que en todos los casos la solución basada en el \textbf{radio discrepancia/rigidez} es mejor en comparación con las demás, obteniendo el resultado óptimo en una gran mayoría de los casos. Teniendo esto en cuenta, se calculó qué tan cercana era esta solución a la solución óptima, utilizando la siguiente fórmula:

\begin{equation}
	\left ( \frac{ \text{ valor solución voraz } }{ \text{ valor solución óptima }} - 1 \right ) * 100
\end{equation}


Este valor se calculó para cada caso de prueba, y se obtuvo que la calidad de la solución encontrada en comparación a la solución óptima es en promedio de $0.1258 \%$. De esta manera, se concluyó que la métrica basada en el \textbf{radio discrepancia/rigidez} ofrecía la mejor relación entre efectividad y simplicidad. Esta métrica permite una interpretación intuitiva: prioriza los grupos donde moderar es más "rentable" en términos de esfuerzo invertido frente a reducción del conflicto interno.

Vale la pena aclarar que se probaron dos enfoques distintos para el caso del \textbf{radio discrepancia/rigidez}:

\begin{enumerate}
	\item Moderar los agentes uno por uno en cada iteración.

	\item Moderar en cada iteración sobre un grupo la máxima cantidad posible de agentes.
\end{enumerate}

Según los resultados, es más adecuado moderar en cada iteración la máxima cantidad de agentes posible, y así, iterar sobre cada grupo una sola vez. Las diferencias en los resultados obtenidos con cada enfoque se pueden explicar por la función techo presente en la función que calcula el esfuerzo requerido para moderar un determinado número de agentes de un grupo. Moderar cada agente uno por uno no da como resultado el mismo esfuerzo que si se moderaran todos a la vez. Adicionalmente, resulta más eficiente el segundo enfoque porque de esta manera la complejidad de la solución es ajena al número de agentes por grupo y solo se ve afectada por el número de grupos en la red.

\subsection{Optimización de la estrategia seleccionada}

Una vez elegida la mejor estrategia voraz, se enfocaron esfuerzos en \textbf{mejorar su eficiencia temporal}, considerando que había oportunidad de mejorar especialmente en el proceso de ordenamiento de los grupos.

Se implementaron dos variantes para esta optimización:

\begin{enumerate}
	\item \textbf{Versión basada en montículo (heap):} Utiliza una estructura de heap máximo para seleccionar iterativamente el grupo con mayor radio, permitiendo una complejidad temporal de $O(n \log n)$.

	\item \textbf{Versión basada en ordenamiento lineal:} Aplica \textbf{Radix Sort} sobre valores enteros escalados del radio, ordenando dígito por dígito cada valor. Grupos con valores de rigidez muy bajos, se ordenan con base en su discrepancia solamente utilizando \textbf{Counting sort}, acotando así el número de dígitos del radio discrepancia/rigidez. De este manera, se alcanza una complejidad teórica de $O(n)$.
\end{enumerate}

\subsection{Consideraciones prácticas}

Aunque desde el punto de vista teórico la versión con ordenamiento lineal debería ser más eficiente, las pruebas empíricas mostraron que la versión basada en la utilización de un montículo (heap) resultaba \textbf{más rápida en la práctica}. Se realizaron pruebas con redes sociales de tamaños muy grandes, variando el número de grupos en cada caso, y se tomaron los respectivos tiempos de ejecución. En la siguiente tabla podemos ver los resultados:

\begin{table}[h]
	\centering
	\begin{tabular}{|c|c|c|}
		\hline
		\textbf{Tamaño de la prueba} & \textbf{Con montículo} & \textbf{Con ordenamiento lineal} \\ \hline
		1000     & 0,0012  & 0,0046 \\ \hline
		10000    & 0,0149  & 0,0807 \\ \hline
		100000   & 0,2716  & 3,5861 \\ \hline
		1000000  & 1,7902  & 22,7417 \\ \hline
		10000000 & 17,0956 & 233,7900 \\ \hline
	\end{tabular}
\end{table}

Como se puede apreciar, la solución con ordenamiento lineal está por debajo de la solución con heap en todos los casos, incluso en los de mayor tamaño.

Aunque es difícil determinar específicamente por qué sucede esto, puede haber varias posibles razones. Para empezar, en la solución con montículos se utiliza la estructura \textbf{heapq}, incluida de manera nativa en Python, pero que internamente está implementado en C. Además, la notación $O(n)$ ignora las constantes multiplicativas. En la práctica, \textbf{Radix} y \textbf{Counting sort} pueden tener constantes grandes debido a:

\begin{itemize}
	\item Múltiples pasadas sobre los datos (una por cada dígito o valor).

	\item Operaciones adicionales como \textbf{escalado}, \textbf{creación de buckets}, y \textbf{conversión de tipos}.

	\item Uso intensivo de estructuras auxiliares (listas, arrays de conteo).
\end{itemize}

De esta manera, en la práctica puede resultar mucho más eficiente utilizar la versión con \textbf{heapq}. Sin embargo, como nos interesa en mayor medida la complejidad teórica, nos quedaremos con la versión de ordenamiento lineal, considerando también que su implementación es más interesante y vale la pena ver más a detalle.

\subsection{Descripción del algoritmo voraz}

Este algoritmo implementa una \textbf{estrategia voraz} para moderar agentes en una red social con el objetivo de minimizar el conflicto interno, sin exceder un presupuesto de esfuerzo $r_{ \max }$. Se basa en \textbf{ordenar previamente} los grupos de agentes de manera eficiente usando algoritmos de \textbf{ordenamiento lineal} (Counting sort y Radix sort), de modo que las decisiones de moderación puedan hacerse rápidamente en orden de prioridad.

\subsubsection{Métrica de decisión}

Cada grupo de agentes $G$ se caracteriza por:

\begin{itemize}
	\item Un número de agentes $n$.

	\item Dos opiniones $o_1, o_2$.

	\item Un nivel de rigidez $r$.
\end{itemize}

La métrica utilizada para priorizar los grupos es el \textbf{radio discrepancia/rigidez} dado por:

\begin{equation}
	\text{radio}(G) = \frac{ |o_1 - o_2| }{ r }
\end{equation}

La estrategia voraz elige moderar primero los grupos que ofrecen \textbf{mayor discrepancia relativa por unidad de esfuerzo}, es decir, aquellos con mayores valores para la métrica.

Para garantizar una mejor eficiencia y un tratamiento especial de casos extremos, los grupos se dividen en dos categorías:

\begin{enumerate}
	\item \textbf{Grupos prioritarios}: aquellos con rigidez $r < 10^{ -6 }$. En estos, el esfuerzo requerido por agente es tan bajo que conviene moderarlos primero, ordenándolos simplemente por discrepancia con \textbf{Counting sort}.

	\item \textbf{Grupos normales}: se ordenan en orden descendente según la métrica definida, utilizando \textbf{Radix sort} para lograr una eficiencia del orden $O(n)$.
\end{enumerate}

\subsubsection{Pasos del algoritmo}

\begin{enumerate}
	\item \textbf{Evaluación rápida de caso trivial}:
		\begin{itemize}
			\item Si el esfuerzo total requerido para moderar todos los agentes es menor o igual al presupuesto $r_{ \max }$, se modera a todos los agentes de todos los grupos.
		\end{itemize}

	\item \textbf{Separación de grupos}:
		\begin{itemize}
			\item Se dividen los grupos en \textbf{prioritarios} y \textbf{normales}, según su rigidez.
		\end{itemize}

	\item \textbf{Ordenamiento eficiente}:
		\begin{itemize}
			\item Se ordenan los grupos prioritarios por discrepancia (de mayor a menor) usando \textbf{Counting sort}.

			\item Se ordenan los grupos normales de acuerdo con su radio discrepancia/rigidez (de mayor a menor) usando \textbf{Radix sort}. Para esto, se convierten los valores del radio a enteros utilizando un factor de escalamiento ($10^6$) que permita conservar precisión, y se ordenan dígito por dígito internamente con \textbf{Counting sort}.

			\item Finalmente, se concatenan ambos grupos, dejando primero al grupo prioritario.
		\end{itemize}

	\item \textbf{Moderación secuencial}:
		\begin{itemize}
			\item Se recorren los grupos ordenados, moderando la mayor cantidad posible de agentes en cada uno, sin exceder el presupuesto de esfuerzo.
		\end{itemize}

	\item \textbf{Finalización}:
		\begin{itemize}
			\item El proceso se detiene cuando se agota el presupuesto de esfuerzo disponible o no hay más grupos por moderar.
		\end{itemize}
\end{enumerate}

\subsubsection{¿Entendimos el algoritmo?}

\begin{enumerate}
	\item \textbf{Entrada:} $RS_1 = (\langle 3,-100,50,0.5 \rangle,\langle 1,100,80,0.1 \rangle,\langle 1,-10,0,0.5 \rangle,80)$

	\textbf{Descripción de los grupos:}
		\begin{itemize}
			\item Grupo 0: $3$ agentes, discrepancia $150$, rigidez $0.5$ $\rightarrow$ $\text{ratio} = \frac{ 150 }{ 0.5 } = 300$.

			\item Grupo 1: $1$ agente, discrepancia $20$, rigidez $0.1$ $\rightarrow$ $\text{ratio} = \frac{ 20 }{ 0.1 } = 200$.

			\item Grupo 2: $1$ agente, discrepancia $10$, rigidez $0.5$ $\rightarrow$ $\text{ratio} = \frac{ 10 }{ 0.5 } = 20$.
		\end{itemize}

	\textbf{Orden tras ordenamiento:} Grupo $0$, luego Grupo $1$, luego Grupo $2$.

	\textbf{Moderación:}
	\begin{itemize}
		\item Grupo 0:
			\begin{itemize}
				\item $\text{Esfuerzo por agente} = 150 * 0.5 = 75$.

				\item Puede moderar solo $1$ agente (porque $75 \leq 80$).

				\item $\text{Presupuesto restante} = 80 - 75 = 5$.
			\end{itemize}
		\item Grupo 1:
			\begin{itemize}
				\item $\text{Esfuerzo por agente} = 20 * 0.1 = 2$.

				\item Puede moderar $2$ agentes, pero el grupo solo tiene $1$, así que modera $1$.

				\item $\text{Presupuesto restante} = 5 - 2 = 3$.
			\end{itemize}
		\item Grupo 2:
			\begin{itemize}
				\item $\text{Esfuerzo por agente} = 10 * 0.5 = 5$.

				\item No puede moderar (presupuesto insuficiente).
			\end{itemize}
	\end{itemize}

	\textbf{Resultado final:} [1, 1, 0] $\rightarrow$ Es decir, $1$ agente moderado del grupo $0$ y $1$ del grupo $1$.

	\textbf{Conflicto interno resultante:}
	\begin{equation}
		CI\left( { RS_1 }^\prime \right) = \frac{ 1 * (-150)^2 + 0 + (-10)^2 }{ 3 } = \frac{ 22500 + 0 + 100 }{ 3 } = \frac{ 22600 }{ 3 } = 15033.33
	\end{equation}

	\item \textbf{Entrada:} $RS_2 = (\langle 3,-100,100,0.8 \rangle, \langle 2,100,80,0.5 \rangle, \langle 4,-10,10,0.5 \rangle,400)$

	\textbf{Descripción de los grupos:}
		\begin{itemize}
			\item Grupo 0: $3$ agentes, discrepancia $200$, rigidez $0.8$ $\rightarrow$ $\text{ratio} = \frac{ 200 }{ 0.8 } = 250$.

			\item Grupo 1: $2$ agentes, discrepancia $20$, rigidez $0.5$ $\rightarrow$ $\text{ratio} = \frac{ 20 }{ 0.5 } = 40$.

			\item Grupo 2: $4$ agentes, discrepancia $20$, rigidez $0.5$ $\rightarrow$ $\text{ratio} = \frac{ 20 }{ 0.5 } = 40$.
		\end{itemize}

	\textbf{Orden tras ordenamiento:} Grupo $0$, luego Grupo $1$, luego Grupo $2$.

	\textbf{Moderación:}
	\begin{itemize}
		\item Grupo 0:
			\begin{itemize}
				\item $\text{Esfuerzo por agente} = 200 * 0.8 = 160$.

				\item Puede moderar $2$ agentes ($320$ esfuerzo).

				\item $\text{Presupuesto restante} = 400 - 320 = 80$.
			\end{itemize}
		\item Grupo 1:
			\begin{itemize}
				\item $\text{Esfuerzo por agente} = 20 * 0.5 = 10$.

				\item Puede moderar $2$ agentes ($20$ esfuerzo).

				\item $\text{Presupuesto restante} = 80 - 20 = 60$.
			\end{itemize}
		\item Grupo 2:
			\begin{itemize}
				\item $\text{Esfuerzo por agente} = 20 * 0.5 = 10$.

				\item Puede moderar $4$ agentes ($40$ esfuerzo).

				\item $\text{Presupuesto restante} = 60 - 40 = 20$.
			\end{itemize}
	\end{itemize}

	\textbf{Resultado final:} [2, 2, 4] $\rightarrow$ Es decir, $2$ agentes moderados del grupo $0$, $2$ del grupo $1$ y $4$ del grupo $2$.

	\textbf{Conflicto interno resultante:}
	\begin{equation}
		CI\left( { RS_2 }^\prime \right) = \frac{ 1 * (-200)^2 + 0 + 0 }{ 3 } = \frac{ 40000 }{ 3 } = 13333.33
	\end{equation}

	\item \textbf{Entrada:} $RS_3 = (\langle 2,40,-60,0.25 \rangle,\langle 3,-50,50,0.1 \rangle,75)$

		\textbf{Descripción de los grupos:}
			\begin{itemize}
				\item Grupo 0: $2$ agentes, discrepancia $100$, rigidez $0.25$ $\rightarrow$ $\text{ratio} = \frac{ 100 }{ 0.25 } = 400$.

				\item Grupo 1: $3$ agentes, discrepancia $100$, rigidez $0.1$ $\rightarrow$ $\text{ratio} = \frac{ 100 }{ 0.1 } = 1000$.
			\end{itemize}

		\textbf{Orden tras ordenamiento:} Grupo $1$, luego Grupo $0$.

		\textbf{Moderación:}
		\begin{itemize}
			\item Grupo 1:
				\begin{itemize}
					\item $\text{Esfuerzo por agente} = 100 * 0.1 = 10$.

					\item Puede moderar $3$ agentes ($30$ esfuerzo).

					\item $\text{Presupuesto restante} = 75 - 30 = 45$.
				\end{itemize}
			\item Grupo 0:
				\begin{itemize}
					\item $\text{Esfuerzo por agente} = 100 * 0.25 = 25$.

					\item Puede moderar $1$ agente ($25$ esfuerzo).

					\item $\text{Presupuesto restante} = 45 - 25 = 20$.
				\end{itemize}
		\end{itemize}

		\textbf{Resultado final:} [1, 3] $\rightarrow$ Es decir, $1$ agente moderado del grupo $0$ y $3$ del grupo $1$.

		\textbf{Conflicto interno resultante:}
		\begin{equation}
			CI\left( { RS_3 }^\prime \right) = \frac{ 1 * (100)^2 + 0 }{ 2 } = \frac{ 10000 }{ 2 } = 5000
		\end{equation}

		\item \textbf{Entrada:} $RS_4 = (\langle 1,100,-100,0.01 \rangle,\langle 2,50,-50,0.5 \rangle, 5)$

		\textbf{Descripción de los grupos:}
			\begin{itemize}
				\item Grupo 0: $1$ agente, discrepancia $200$, rigidez $0.01$ $\rightarrow$ $\text{ratio} = \frac{ 200 }{ 0.01 } = 20000$.
				\item Grupo 1: $2$ agentes, discrepancia $100$, rigidez $0.5$ $\rightarrow$ $\text{ratio} = \frac{ 100 }{ 0.5 } = 200$.
			\end{itemize}

		\textbf{Orden tras ordenamiento:} Grupo $0$, luego Grupo $1$.

		\textbf{Moderación:}
		\begin{itemize}
			\item Grupo 0:
				\begin{itemize}
					\item $\text{Esfuerzo por agente} = 200 * 0.01 = 2$.

					\item Puede moderar $1$ agente ($2$ esfuerzo).

					\item $\text{Presupuesto restante} = 5 - 2 = 3$.
				\end{itemize}
			\item Grupo 1:
				\begin{itemize}
					\item $\text{Esfuerzo por agente} = 100 * 0.5 = 50$.

					\item No puede moderar (presupuesto insuficiente).
				\end{itemize}
		\end{itemize}

		\textbf{Resultado final:} [1, 0] $\rightarrow$ Es decir, $1$ agente moderado del grupo $0$ y $0$ del grupo $1$.

		\textbf{Conflicto interno resultante:}
		\begin{equation}
			CI\left( { RS_4 }^\prime \right) = \frac{ 0 + 2 * (100)^2 }{ 2 } = \frac{ 20000 }{ 2 } = 10000
		\end{equation}
\end{enumerate}

Los resultados se resumen en la siguiente tabla:

\begin{table}[h]
	\centering
	\begin{tabular}{|c|c|c|c|}
		\hline
		\textbf{Caso} & \textbf{Estrategia} & \textbf{Conflicto interno} & \textbf{¿Óptima?} \\ \hline
		RS\_1 & [1,1,0] & 15033,33 & Sí \\ \hline
		RS\_2 & [2,2,4] & 13333,33 & Sí \\ \hline
		RS\_3 & [1,3]   & 5000     & Sí \\ \hline
		RS\_4 & [1,0]   & 10000    & Sí \\ \hline
	\end{tabular}
\end{table}

\subsection{Complejidad temporal teórica}

\begin{algorithm}[H]
	\caption{Greedy Moderation with Radix and Counting Sort}
	\begin{algorithmic}[1]
		\If{ $\text{calculate\_max\_effort(social\_network)} \leq \text{social\_network.r\_max}$ }
			\State \Return $[group.n \text{ for each } group \in \text{social\_network.groups}]$
		\EndIf
		\State $n \gets \text{length of social\_network.groups}$
		\State $strategy \gets [0, 0, \dots, 0]$ of size $n$
		\State $remaining\_r \gets \text{social\_network.r\_max}$
		\State $r\_min \gets 10^{-6}$
		\State $priority\_groups \gets [\ ]$
		\State $normal\_groups \gets [\ ]$
		\ForAll{ $group \in \text{social\_network.groups}$ }
			\If{ $group.r < r\_min$ }
				\State $\text{append } group \text{ to } priority\_groups$
			\Else
				\State $ \text{append } group \text{ to } normal\_groups $
			\EndIf
		\EndFor
		\State $sorted\_priority\_groups \gets \text{CountingSortByDiscrepancy}(priority\_groups)$
		\State $sorted\_normal\_groups \gets \text{RadixSortByRatio}(normal\_groups)$
		\State $sorted\_groups \gets \text{Concatenate}(sorted\_priority\_groups, sorted\_normal\_groups)$
		\State $group\_to\_index \gets \{\}$
		\For{ $i \gets 0$ \textbf{to} $n - 1$ }
			\State $group\_to\_index[\text{id}(social\_network.groups[i])] \gets i$
		\EndFor
		\ForAll{ $group \in sorted\_groups$ }
			\If{ $remaining\_r \leq 0$ }
				\State \textbf{break}
			\EndIf
			\State $index \gets group\_to\_index[\text{id}(group)]$
			\State $max\_agents \gets group.n$
			\State $effort\_per\_agent \gets |group.o_1 - group.o_2| \times group.r$
			\If{ $effort\_per\_agent = 0$ \textbf{or} $effort\_per\_agent > remaining\_r$ }
				\State \textbf{continue}
			\EndIf
			\State $max\_possible \gets \text{floor}(remaining\_r / effort\_per\_agent)$
			\State $agents\_to\_moderate \gets \min(max\_agents, max\_possible)$
			\If{ $agents\_to\_moderate > 0$ }
				\State $strategy[index] \gets strategy[index] + agents\_to\_moderate$
				\State $remaining\_r \gets remaining\_r - \lceil agents\_to\_moderate \times effort\_per\_agent \rceil$
			\EndIf
		\EndFor
		\State \Return $strategy$
	\end{algorithmic}
\end{algorithm}

Como se puede apreciar, cada sección del código tiene como máximo un costo de orden lineal $O(n)$. Luego, la suma de todos los costos parciales da como resultado también un orden lineal. Ahora, como se parte de la idea de que Counting sort y Radix sort se implementan correctamente y estos dos son algoritmos de ordenamiento lineal, se puede determinar que el ordenamiento de los grupos se da en tiempo lineal. Sin embargo, es necesario justificar por qué se garantiza la linealidad en ambos casos.

\subsubsection{Counting sort}

Tiene una complejidad teórica $O(n + k)$, donde:

\begin{itemize}
	\item $n$ es el número de elementos a ordenar.

	\item $k$ es el rango máximo de los valores enteros posibles.
\end{itemize}

En este algoritmo, usamos Counting sort para ordenar grupos con \textbf{rigidez muy baja} ($r < r_{ \min }$) por su \textbf{discrepancia}, es decir, por $o_1 - o_2$. Como las opiniones están acotadas entre $-100$ y $100$, la discrepancia máxima es $200$ y la mínima es $0$. Esto significa que el rango de discrepancia es \textbf{constante} (a lo sumo $201$ valores posibles), por lo tanto, la complejidad de Counting sort en este caso es:

\begin{equation}
	O(n + 201) = O(n)
\end{equation}

\subsubsection{Radix sort}

Tiene una complejidad teórica $O(d * (n + b))$, donde:

\begin{itemize}
	\item $n$ es el número de elementos.

	\item $b$ es la base usada para descomponer los números (usualmente base 10).

	\item $d$ es el número de dígitos máximos del valor más grande.
\end{itemize}

En este algoritmo, Radix Sort se aplica sobre la métrica:

\begin{equation}
	\text{radio}(G) = \frac{ |o_1 - o_2| }{ r }
\end{equation}

Aunque esta métrica es real (\textbf{float}), es escalada previamente a un número entero (en este caso, multiplicando por $10^6$) para preservar el orden relativo con suficiente precisión. Dado que $o_1 - o_2$ está acotado y $r \geq 10^{ -6 }$, el valor máximo posible de la métrica escalada es:

\begin{equation}
	\text{radio}_{ \max } = \frac{ 200 }{ 10^{ -6 } } * 10^{ 6 } = 200 * 10^{ 6 }
\end{equation}

Esto significa que los valores del radio tienen como máximo \textbf{$15$ dígitos decimales}, es decir, $d = 15$. Luego, la complejidad de Radix sort en este caso es:

\begin{equation}
	O(15 * (n + 10)) \\
	= O(15 n + 150) \\
	= O(n)
\end{equation}

Porque $d$ y $b$ son constantes, la complejidad es de orden lineal.

\subsection{Corrección del algoritmo}

El algoritmo no garantiza encontrar siempre la solución óptima al problema de minimizar el conflicto interno en una red social bajo una restricción de esfuerzo. Esto se debe a que se trata de una estrategia voraz, que en cada paso toma decisiones locales que parecen óptimas (moderando primero los grupos con menor esfuerzo relativo o discrepancia alta), pero sin considerar el efecto global de esas decisiones sobre la red completa.

La estrategia voraz no explora todas las posibles combinaciones de asignación de esfuerzo, sino que selecciona, de forma determinista y ordenada, aquellos grupos que según una métrica predefinida (como discrepancia o discrepancia/rigidez) parecen más beneficiosos. Por tanto, puede quedar atrapada en óptimos locales, sin alcanzar el mínimo conflicto interno global posible.

\subsubsection{¿Cuándo sí da la respuesta óptima?}

El algoritmo sí produce la solución óptima en ciertos casos particulares, por ejemplo:

\begin{itemize}
	\item Cuando el presupuesto de esfuerzo es suficiente para moderar completamente todos los grupos (caso trivial): en ese caso, la estrategia modera todos los agentes, lo cual es la solución óptima.

	\item Cuando los grupos son homogéneos (misma discrepancia y rigidez), y el esfuerzo se distribuye equitativamente.

	\item Cuando la métrica voraz coincide con el impacto real que tiene moderar un grupo en la reducción del conflicto interno, por ejemplo, si todos los grupos tienen rigidez muy baja (donde la discrepancia domina el cálculo del conflicto interno), o cuando el presupuesto es tan pequeño que solo se puede moderar un único grupo y la elección más beneficiosa es evidente.
\end{itemize}

\subsubsection{¿Cuándo puede no dar la respuesta óptima?}

El algoritmo puede fallar al encontrar la mejor solución en los siguientes escenarios:

\begin{itemize}
	\item Cuando hay una combinación de grupos donde moderar parcialmente varios grupos produce menos conflicto interno que moderar completamente uno solo (aunque este tenga mejor puntuación según la métrica voraz).

	\item Cuando el impacto acumulativo de moderar ciertos grupos no se alinea con la métrica usada para ordenarlos (por ejemplo, la discrepancia/rigidez no siempre refleja la mejor inversión del esfuerzo si hay casos con rigidez baja pero poco impacto en el conflicto interno).
\end{itemize}

\section{Fuerza Bruta}

\subsection{Complejidad}

El algoritmo de fuerza bruta implementado en el proyecto presenta una complejidad temporal de orden exponencial. Esta complejidad se deriva del hecho de que el algoritmo explora de manera exhaustiva todas las posibles combinaciones de estrategias de moderación para los grupos que conforman la red social.

Dado un conjunto de $k$ grupos, donde cada grupo $i$ posee $n_i$ agentes, el algoritmo genera el producto cartesiano de los posibles valores de moderación para cada grupo, los cuales varían desde $0$ hasta $n_i$. Como resultado, el número total de combinaciones evaluadas es:

\begin{equation}
	\prod_{ i = 1 }^k (n_i + 1)
\end{equation}

Sobre cada combinación, el algoritmo calcula el esfuerzo total requerido y el conflicto interno resultante (si el esfuerzo no excede el esfuerzo disponible). Esto se traduce en una complejidad temporal de:

\begin{equation}
	O \left( \prod_{ i = 1 }^k (n_i + 1) \cdot 2 k \right)
\end{equation}

\begin{quote}
	Tanto para calcular el esfuerzo total como el conflicto interno para cada combinación implica recorrer todos los grupos, lo que añade un factor de $2 k$ a la complejidad.
\end{quote}

Esta naturaleza combinatoria implica que el tiempo de ejecución del algoritmo crece de forma exponencial respecto al número de grupos y al número de agentes por grupo. En consecuencia, este enfoque resulta computacionalmente costoso para redes sociales de tamaño medio o grande, siendo únicamente viable en escenarios reducidos donde la cantidad de grupos y agentes es limitada.

En el caso particular en que todos los grupos tengan el mismo número de agentes, es decir, $n_i = m$ para todo $i$, la expresión anterior se simplifica a:

\begin{align}
	& O \left((m + 1)^k \cdot 2 k \right ) \\
	& = O(m^k \cdot k)
\end{align}

Esta forma resume la naturaleza exponencial del algoritmo, destacando cómo su complejidad se incrementa significativamente al aumentar el número de grupos ($k$) o la cantidad de agentes por grupo ($m$).

\subsection{Corrección}

El algoritmo de fuerza bruta implementado en el proyecto garantiza la obtención de la solución óptima para el problema planteado. Este algoritmo evalúa todas las posibles combinaciones de moderación entre los grupos de agentes de la red social.

Este enfoque tiene como objetivo garantizar que:

\begin{itemize}
	\item Se consideren todas las estrategias viables, es decir, todas las formas posibles de moderar entre $0$ y $n_i$ agentes en cada grupo $i$.

	\item Se verifique, para cada combinación, si el esfuerzo total requerido no excede el límite permitido $R_{ \max }$.

	\item Se calcule el conflicto interno resultante para cada estrategia válida.

	\item Finalmente, se elija la combinación que minimiza el conflicto interno, cumpliendo así con el objetivo del problema.
\end{itemize}

Este procedimiento asegura la corrección del resultado, ya que no se omite ninguna posibilidad y se selecciona óptimamente la estrategia más beneficiosa dentro de las restricciones dadas. Sin embargo, esta exactitud tiene como costo una alta complejidad computacional, lo cual hace que el algoritmo solo sea viable para instancias pequeñas o moderadas del problema.

\section{Programación dinámica}

\subsection{Caracterización de la subestructura óptima}

Definimos la notación $\operatorname{ IC }(i,r)$ como el problema de minimizar el conflicto interno utilizando los primeros $i$ grupos de agentes con un esfuerzo disponible $r$. La notación $\operatorname{ modIC }(i,r)$ denota la secuencia de decisiones óptimas (es decir, el número de agentes a moderar en cada grupo) para los grupos $i$ hasta $n$ utilizando $r$ de esfuerzo, donde la secuencia vacía $\langle \rangle$ indica que no se realizan más moderaciones.

\begin{equation}
	\operatorname{ modIC }(i,r) = \begin{cases}
		\langle \rangle                                                             & i = n + 1 \\
		k_i :: \operatorname{ modIC }(i + 1,r - \operatorname{ e\_effort }(i,k_i))  & i \neq n
	\end{cases}
\end{equation}

\begin{equation}
	\operatorname{ IC }(i,R_{ \max }) = \operatorname{ modIC }(1,R_{ \max })
\end{equation}

\subsection{Valor recursivo de la solución óptima}

- $\operatorname{ e\_effort }(i,k)$: es el esfuerzo requerido para \textbf{moderar} $k$ agentes del grupo $i$ ($\left \lceil |o_{ i,1 } - o_{ i,2 }| \cdot r_i \cdot k \right \rceil$).

- $\operatorname{ conflict }(i,k)$: es la contribución al conflicto interno del grupo $i$ luego de \textbf{moderar} $k$ agentes ($(n_i - k) * (o_{ i,1 } - o_{ i,2 })^2$).

\subsubsection{Normalización en cada paso}

\begin{equation}
	\operatorname{ { recIC }_1 }(i,r) = \begin{cases}
		0                                                                                                                                                                                        & i = 0 \\
		\min_{ 0 \leq k_i \leq n_i } \left \{ \frac{ (i - 1) \cdot \operatorname{ { recIC }_1 }(i - 1,r - \operatorname{ e\_effort }(i,k_i)) + \operatorname{ conflict }(i,k_i) }{ i } \right \} & i > 0
	\end{cases}
\end{equation}

\begin{equation}
	\operatorname{ valueIC }(n,R_{ \max }) = \operatorname{ { recIC }_1 }(n,R_{ \max })
\end{equation}

\subsubsection{Acumulación total y normalización final}

\begin{equation}
	\operatorname{ { recIC }_2 }(i,r) = \begin{cases}
		0                                                                                                                                             & i = 0 \\
		\min_{ 0 \leq k_i \leq n_i } \{\operatorname{ { recIC }_2 }(i - 1,r - \operatorname{ e\_effort }(i,k_i)) + \operatorname{ conflict }(i,k_i)\} & i > 0
	\end{cases}
\end{equation}

\begin{equation}
	\operatorname{ valueIC }(n,R_{ \max }) = \frac{ \operatorname{ { recIC }_2 }(n,R_{ \max }) }{ n }
\end{equation}

\subsubsection{Justificación equivalencia}

Sea $F(i,r)$ la suma total del conflicto acumulado en los $i$ primeros grupos.

Ambas formulaciones calculan el mismo valor $\operatorname{ valueIC }(n,R_{ \max }) = \frac{ 1 }{ n } \sum_{ i = 0 }^{ n - 1 } \operatorname{ conflict }(i,k_i)$.

\begin{itemize}
	\item Caso base: para $i = 0$, ambas definiciones retornan $0$.

	\item Paso inductivo: supongamos que para $i - 1$, $\operatorname{ { recIC }_1 }(i,r') = \frac{ F(i - 1,r') }{ i - 1 }$ y $\operatorname{ { recIC }_2 }(i,r') =F(i - 1,r')$.

	\item \begin{itemize}
			\item $\operatorname{ { recIC }_1 }$.
			\begin{align}
				& \operatorname{ { recIC }_1 }(i,r) = \frac{ (i - 1) \cdot \operatorname{ { recIC }_1 }(i - 1,r - \operatorname{ e\_effort }(i,k_i)) + \operatorname{ conflict }(i,k_i) }{ i } \\
				& = \frac{ F(i - 1,r') + \operatorname{ conflict }(i,k_i) }{ i }
			\end{align}
			\item $\operatorname{ { recIC }_2 }$.
			\begin{align}
				& \operatorname{ { recIC }_2 }(i,r) = \operatorname{ { recIC }_2 }(i - 1,r - \operatorname{ e\_effort }(i,k_i)) + \operatorname{ conflict }(i,k_i) \\
				& = F(i - 1,r') + \operatorname{ conflict }(i,k_i)
			\end{align}
		\end{itemize}
\end{itemize}

Al final $\operatorname{ valueIC }(n,R_{ \max }) = \frac{ \operatorname{ { recIC }_2 }(n,R_{ \max }) }{ n } = \frac{ F(n,R_{ \max }) }{ n }$, que coincide con $\operatorname{ { recIC }_1 }(n,R_{ \max })$.

Lo cual tiene sentido, minimizar para $\frac{ F(i - 1,r') + \operatorname{ conflict }(i,k_i) }{ i }$ es equivalente a minimizar $F(i - 1,r') + \operatorname{ conflict }(i,k_i)$ porque dividir por una constante positiva ($i$) no cambia la elección del $k_i$ que da el mínimo valor.

\subsection{Algoritmo para calcular el costo de una solución óptima}

Para calcular el costo óptimo mediante programación dinámica, utilizamos un bottom-up que construye sistemáticamente la solución a partir de los casos base.

Definimos una matriz $storage$ donde $storage[i][r]$ representa el mínimo conflicto interno posible considerando los primeros $i$ grupos con un esfuerzo disponible $r$. El algoritmo completa esta matriz iterativamente:

\begin{algorithm}[H]
	\caption{cálculo del costo óptimo mediante programación dinámica (bottom-up)}
	\begin{algorithmic}[1]
		\State $n \gets$ número de grupos
		\State $r_{max} \gets$ esfuerzo máximo disponible
		\State inicializar $storage[0][r] = 0$ para todo $r \in [0,r_{ \max }]$
		\State inicializar $storage[i][r] = \infty$ para todo $i \in [1,n]$, $r \in [0, r_{ \max }]$

		\For{ $i = 1$ hasta $n$ }
			\State obtener grupo actual: $a_{ i - 1 } = \langle n_i,o_{ i,1 },o_{ i,2 },r_i \rangle$
			\State $conflict\_per\_agent \gets (o_{ i,1 } - o_{ i,2 })^2$
			\State $effort\_per\_agent \gets |o_{ i,1 } - o_{ i,2 }| \cdot r_i$

			\For{ $r = 0$ hasta $r_{ \max }$ }
				\For{ $k = 0$ hasta $n_i$ }
					\State $required\_effort \gets \lceil effort\_per\_agent \cdot k \rceil$
					\If{ $required\_effort \leq r$ }
						\State $remaining\_conflict \gets (n_i - k) \cdot conflict\_per\_agent$
						\State $total\_conflict \gets storage[i - 1][r-required\_effort] + remaining\_conflict$
						\If{ $total\_conflict < storage[i][r]$ }
							\State $storage[i][r] \gets total\_conflict$
						\EndIf
					\EndIf
				\EndFor
			\EndFor
		\EndFor

		\State \Return $storage[n][r_{ \max }]$
	\end{algorithmic}
\end{algorithm}

El valor $storage[n][r_{ \max }]$ representa la suma total del conflicto mínimo posible. Para obtener el conflicto interno normalizado según la definición del problema, debemos dividir este valor por $n$:

\begin{equation}
	\operatorname{ valueIC }(n,R_{ \max }) = \frac{ storage[n][r_{ \max }] }{ n }
\end{equation}

\subsection{Algoritmo para calcular una solución óptima}

Mientras que la sección anterior nos permite calcular el valor mínimo de conflicto interno, también necesitamos determinar la estrategia óptima que produce dicho valor. Para reconstruir esta estrategia, utilizamos una matriz adicional durante el proceso que registra las decisiones óptimas.

Definimos una matriz $decisions$ donde $decisions[i][r]$ representa el número óptimo de agentes a moderar del grupo $i$ cuando se dispone de un esfuerzo $r$. Esta matriz se completa durante el mismo proceso iterativo en que calculamos el costo mínimo.

\begin{algorithm}[H]
	\caption{registro de decisiones (extensión del algoritmo anterior)}
	\begin{algorithmic}
		\State inicializar $decisions[i][r] = 0$ para todo $i \in [0,n]$, $r \in [0,r_{ \max }]$
		\State ...
		\If{ $total\_conflict < storage[i][r]$ }
			\State $storage[i][r] \gets total\_conflict$
			\State $decisions[i][r] \gets k$ \Comment{registramos la decisión óptima}
		\EndIf
		\State ...
	\end{algorithmic}
\end{algorithm}

Una vez completadas las matrices $storage$ y $decisions$, podemos reconstruir la estrategia óptima mediante un proceso de retroceso:

\begin{algorithm}[H]
	\caption{reconstrucción de la estrategia óptima}
	\begin{algorithmic}[1]
		\State $n \gets$ número de grupos
		\State $r_{ \max } \gets$ esfuerzo máximo disponible
		\State inicializar $optimal\_strategy$ como un arreglo de $n$ ceros
		\State $remaining\_effort \gets r_{ \max }$

		\For{$i = n$ hasta $1$ (en orden descendente)}
			\State $k \gets decisions[i][remaining\_effort]$ \Comment{número óptimo de agentes a moderar}
			\State $optimal\_strategy[i - 1] \gets k$

			\State obtener grupo actual: $a_{ i - 1 } = \langle n_i,o_{ i,1 },o_{ i,2 },r_i \rangle$
			\State $effort\_per\_agent \gets |o_{ i,1 } - o_{ i,2 }| \cdot r_i$
			\State $required\_effort \gets \lceil effort\_per\_agent \cdot k \rceil$
			\State $remaining\_effort \gets remaining\_effort - required\_effort$
		\EndFor

		\State \Return $optimal\_strategy$
	\end{algorithmic}
\end{algorithm}

El resultado $optimal\_strategy$ es un arreglo donde la posición $i$ indica cuántos agentes deben ser moderados del grupo $i$ para lograr el mínimo conflicto interno posible. Esta estrategia satisface la restricción de que su esfuerzo total no excede $R_{ \max }$.

La estrategia resultante $E = \langle e_0,e_1,\ldots,e_{ n - 1 } \rangle$ representa nuestra solución final al problema, donde cada $e_i$ indica exactamente cuántos agentes del grupo $i$ deben ser moderados para minimizar el conflicto interno de la red social.

\subsection{Complejidad}

\subsubsection{Rellenando la matriz $storage$ y $decisions$}

\begin{algorithm}[H]
	\caption{estructura del cálculo del costo óptimo mediante programación dinámica (bottom-up)}
	\begin{algorithmic}[1]
		\State ...
		\For{ $i = 1$ hasta $n$ }
			\State ...
			\For{ $r = 0$ hasta $r_{ \max }$ }
				\For{ $k = 0$ hasta $n_i$ }
					\State ...
				\EndFor
			\EndFor
		\EndFor

		\State \Return $storage[n][r_{ \max }]$
	\end{algorithmic}
\end{algorithm}

\begin{itemize}
	\item Temporal: $O(n \cdot R_{ \max } \cdot \max(n_i))$, donde $n$ es el número de grupos, $R_{ \max }$ es el esfuerzo máximo disponible y $\max(n_i)$ es el número máximo de agentes en cualquier grupo.

	\item Espacial: $O(n \cdot R_{ \max })$, donde $n$ es el número de grupos, $R_{ \max }$ es el esfuerzo máximo disponible.
\end{itemize}

\begin{quote}
	Esto es válido porque en el ciclo interior, las operaciones que se hacen son asignaciones, es decir, tienen complejidad $O(1)$.
\end{quote}

\subsubsection{Recuperando la solución de la matriz $decisions$}

\begin{algorithm}[H]
	\caption{estructura de la reconstrucción de la estrategia óptima}
	\begin{algorithmic}[1]
		\State ...
		\State inicializar $optimal\_strategy$ como un arreglo de $n$ ceros
		\State ...

		\For{$i = n$ hasta $1$ (en orden descendente)}
			\State ...
		\EndFor

		\State \Return $optimal\_strategy$
	\end{algorithmic}
\end{algorithm}

\begin{itemize}
	\item Temporal: $O(n)$, donde $n$ es el número de grupos.

	\item Espacial: $O(n)$, donde $n$ es el número de grupos.
\end{itemize}

\begin{quote}
	Esto es válido porque en el ciclo interior, las operaciones que se hacen son asignaciones, es decir, tienen complejidad $O(1)$.
\end{quote}

\hrule

Por lo tanto, la complejidad temporal del algoritmo es $O(n \cdot R_{ \max } \cdot \max(n_i) + n)$ y la espacial es $O(n \cdot R_{ \max } + n)$.

\section{Comparación entre estrategias}

\begin{table}[H]
	\centering
	\caption{Comparación de complejidad entre estrategias de moderación}
	\begin{tabular}{|l|c|c|c|}
		\hline
		\textbf{Estrategia} & \textbf{Complejidad temporal} & \textbf{Complejidad espacial} & \textbf{¿Óptima?} \\ \hline
		Voraz                 & $O(n)$                                  & $O(n)$                  & No \\
		Fuerza bruta          & $O(m^k \cdot k)$                        & $O((m + 1)^k)$          & Sí \\
		Programación dinámica & $O(n \cdot R_{ \max } \cdot \max(n_i))$ & $O(n \cdot R_{ \max })$ & Sí \\
	\hline
	\end{tabular}
\end{table}

Cada una de las estrategias analizadas presenta ventajas y desventajas que deben ser consideradas al momento de seleccionar la más adecuada para un escenario real:

\begin{itemize}
	\item \textbf{Voraz:}
	\begin{itemize}
		\item \textbf{Ventajas:} Su principal fortaleza es la eficiencia, ya que puede manejar redes sociales de gran tamaño en tiempos muy reducidos y con bajo consumo de memoria. Es fácil de implementar y ajustar, y en la práctica suele obtener soluciones muy cercanas al óptimo.

		\item \textbf{Desventajas:} No garantiza la obtención de la solución óptima en todos los casos.
	\end{itemize}

	\item \textbf{Fuerza bruta:}
	\begin{itemize}
		\item \textbf{Ventajas:} Garantiza encontrar la solución óptima, ya que explora exhaustivamente todas las combinaciones posibles. Es útil como referencia para validar la calidad de otras estrategias en instancias pequeñas.

		\item \textbf{Desventajas:} Su complejidad exponencial lo hace inviable para redes sociales medianas o grandes, ya que el tiempo y la memoria requeridos crecen rápidamente con el número de grupos y agentes.
	\end{itemize}

	\item \textbf{Programación dinámica:}
	\begin{itemize}
		\item \textbf{Ventajas:} Ofrece una solución óptima con una complejidad mucho menor que la fuerza bruta, siendo factible para instancias de tamaño moderado. Permite un balance entre exactitud y eficiencia.

		\item \textbf{Desventajas:} Aunque mejora respecto a la fuerza bruta, sigue siendo costosa en términos de tiempo y memoria para redes muy grandes o cuando el presupuesto de esfuerzo es alto, ya que la complejidad depende linealmente de ambos factores.
	\end{itemize}
\end{itemize}

En aplicaciones reales donde la escala de la red social es grande y se requiere una respuesta rápida, la estrategia voraz es la opción más práctica, sacrificando una mínima cantidad de optimalidad a cambio de eficiencia. Para instancias pequeñas o cuando se requiere la mejor solución posible, la programación dinámica es preferible. La fuerza bruta queda relegada a propósitos de validación o análisis teórico en casos muy reducidos.

\end{document}
